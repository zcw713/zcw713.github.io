## 编译流程
- iOS编译原理，涉及到的编译过程：预处理、编译器、汇编器、链接器；
- iOS编译对应的Xcode中build settings配置；
- 什么是mach.o文件；
- ipa生成过程；
- 启动加速，pre main过程，main过程，main之后；
- 什么是静态库、动态库，以及他们如何被加载；
- 《深入解析Mac OS X & iOS操作系统》

预处理：宏定义展开、引用文件替换、删除注释；

预处理后的源代码 -》
词法分析：将代码分割，生成 token 记号；
语法分析：抽象语法树生成；
语义分析：编译器阶段主要是静态语义分析，通常包括声明和类型的匹配、类型转换，生成中间代码；
中间代码-编译器前端：负责源代码优化，产生机器无关的中间代码；(对于一些跨平台的编译器而言，可以使用一个前端，对应不同机器平台的多个后端)
中间代码-编译器后端：
    1.代码生成器：将中间代码转换成目标机器代码，这个过程依赖于目标机器，因为不同的机器有着不同的字长、寄存器、整数数据类型、浮点数据类型等；
    2.目标代码优化器：对目标代码进行优化，比如选择合适的寻址方式、使用位移来代替乘法运算、删除多余指令等。
-》目标文件
以上是【源代码】->【目标文件】的编译过程。

目标文件从结构上讲，它是已经编译后的可执行文件，只是还没有经过链接过程，其中可能还有些符号或有些地址还没有被调整。但它本身是按照可执行文件格式存储的，只是跟真正的可执行文件在结构上稍有不同。
不仅是目标文件按照可执行文件格式存储，动态链接库(DLL)、静态链接库(.a)文件都是按照可执行文件格式存储。

汇编产生的背景？
    早期的机器码编写代码的方式非常繁琐，比如程序修改之后导致目标地址的变化，程序员需要重新计算每个子程序或跳转的目标地址，这种人工进行指令的修正以确保所以跳转目标地址都正确，在程序规模越来越大以后变得更繁琐和复杂。
    后来先驱者发明了汇编语言，使用接近人类的各种符号和标记来帮助记忆。比如使用 jmp 替代之前的机器码来表示跳转指令；使用符号来标记位置，比记住从某个位置开始的第几条指令是某某程序方便得多，这种使用符号的方法是人们从具体的指令地址中逐步解放出来。
    符号（Symbol）随着汇编语言的普及被迅速使用，它用来表示一个地址，这个地址可以是一个函数地址，也可以是一个变量的起始地址。

重定位：重新计算各个目标地址的过程。

为什么需要链接？
    在现代软件开发过程中，软件往往拥有成千上万个模块，这些模块之间相互依赖又相对独立。这种按照层次化及模块化存储和组织源代码有很多好处，比如代码更容易阅读、理解、重用，每个模块可以独立开发、编译、测试，改变部分代码不需要编译整个程序等。
    程序被分割成多个模块之后，需要将这些模块组合成一个单一的程序，这个模块拼接的过程就是：链接。

模块之间如何组合存在一个问题，模块之间如何通信？
    模块之间的通信包含：模块间函数调用、模块之间的变量访问。函数的访问必须知道目标函数地址，变量访问也许知道目标变量的地址，所以它们是同一个问题，模块间符号的引用。
    
链接：
> 通俗来讲：链接是把各个模块之间的相互引用的部分处理好，使得各个模块之间能够正确的衔接。
> 链接的过程主要包括：地址和空间分配、符号决议（地址绑定）、重定位等。
> 链接的目的是将 .o(目标文件)和库(比如：运行时库)一起链接成可执行文件。

静态链接：通过链接器修正编译期未处理的目标地址。
举例：main.c中使用了另一个模块func.c中的函数foo()。我们在main.c模块中每一处调用foo的时候都必须确切的知道foo这个函数的地址，但是由于每个模块是单独编译的，编译器在编译main.c的时候并不知道foo函数的地址，所以它暂时把这些调用foo指令的目标地址搁置，等待最后链接的时候由链接器将这些指令的目标地址修正。
使用链接器，可以直接引用其他模块的函数和全局变量而无需知道它们的地址，因为链接器在链接的时候，会根据你所引用的符号foo，自动去相应的func.c模块查找foo的地址，然后将main.c模块所有引用到foo的指令重新修正，让它们的目标地址为真正的函数地址。
全局变量引用处理：如果B文件中要使用在A文件中声明的全局变量，由于在编译文件B的时候，编译器并不知道变量的目标地址，此时将目标地址置为0，等待链接器将目标文件A和B链接起来的时候再将B文件的目标地址进行修正。这个地址修正的过程也被叫做重定位。







